<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>恋ぐるラボ｜恋愛仙人チャット</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #fff7f8;
      --card: #ffffff;
      --ink: #111827;
      --muted: #6b7280;
      --accent: #f97373;
      --accent-dark: #e45454;
      --line: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Yu Gothic", "YuGothic",
        system-ui, "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at top left, #ffe6ec, #fff7f8 40%, #ffffff 80%);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(229, 231, 235, 0.7);
    }
    .header-inner {
      max-width: 960px;
      margin: 0 auto;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 12px;
      background: linear-gradient(135deg, #f97373, #fb7185);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 18px;
      font-weight: 700;
    }
    .logo-text-main {
      font-weight: 700;
      letter-spacing: 0.05em;
      font-size: 16px;
    }
    .logo-text-sub {
      font-size: 11px;
      color: var(--muted);
      border: 1px solid #fecaca;
      border-radius: 999px;
      padding: 2px 8px;
      margin-left: 4px;
      background: #fff7f7;
    }
    .header-nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
    }
    .header-link {
      color: var(--muted);
      text-decoration: none;
      padding: 4px 0;
    }
    .header-link:hover {
      color: var(--ink);
    }
    .header-cta {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(249, 115, 115, 0.35);
    }
    .header-cta:hover {
      background: var(--accent-dark);
    }

    .chat-layout {
      max-width: 960px;
      margin: 0 auto;
      padding: 32px 16px 40px;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 28px;
      min-height: calc(100vh - 80px);
    }
    @media (max-width: 800px) {
      .chat-layout {
        grid-template-columns: minmax(0, 1fr);
        padding-top: 20px;
      }
    }

    .chat-intro-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 12px;
      line-height: 1.6;
    }
    .chat-intro-lead {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.8;
      margin-bottom: 18px;
    }
    .chat-intro-note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 12px;
    }

    .chat-card {
      background: var(--card);
      border-radius: 20px;
      padding: 14px 12px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
      border: 1px solid rgba(248, 113, 113, 0.25);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 160px);
      max-height: none;
    }
    @media (max-width: 800px) {
      .chat-card { height: calc(100vh - 200px); }
    }

    .small {
      color: var(--muted);
      font-size: 12px;
    }
    .step-hint { margin-top: 6px; }

    .chat-box {
      height: 100%;
      overflow-y: auto;
      border-radius: 14px;
      background: #fef2f2;
      padding: 8px;
      border: 1px solid #ffe4e6;
      margin-top: 6px;
      flex: 1 1 auto;
      min-height: 0;
    }

    .row { display: flex; margin: 6px 0; }
    .row .bubble {
      max-width: 82%;
      padding: 8px 10px;
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
      line-height: 1.7;
    }
    .row.assistant { justify-content: flex-start; }
    .row.assistant .bubble {
      background: #ffffff;
      color: #111827;
      border-bottom-left-radius: 4px;
    }
    .row.user { justify-content: flex-end; }
    .row.user .bubble {
      background: #f97373;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .choices {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .choice {
      appearance: none;
      border: none;
      background: #111827;
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
    }
    .choice.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    .choice:focus { outline: 3px solid #fecaca; }

    .composer {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      align-items: center;
    }
    .composer input { flex: 1; }

    .muted { color: var(--muted); }

    .chat-input {
      width: 100%;
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #fecaca;
      outline: none;
      font-family: inherit;
    }
    .chat-input:focus {
      border-color: #fb7185;
      box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.2);
    }

    .chat-send-btn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }
    .chat-send-btn:hover { background: var(--accent-dark); }
    .chat-send-btn[disabled] {
      opacity: 0.6;
      cursor: default;
    }
  </style>
</head>

<body>
<header>
  <div class="header-inner">
    <div class="logo">
      <div class="logo-mark">恋</div>
      <div>
        <div class="logo-text-main">恋ぐるラボ</div>
        <span class="logo-text-sub">恋愛仙人チャット</span>
      </div>
    </div>
    <nav class="header-nav">
      <a href="index.html" class="header-link">トップに戻る</a>
      <button class="header-cta" onclick="window.location.href='index.html'">LPを見る</button>
    </nav>
  </div>
</header>

<main class="chat-layout">
  <section>
    <h1 class="chat-intro-title">恋愛仙人に、今の状況をそのまま話してみてください。</h1>
    <p class="chat-intro-lead">
      「相手との関係」「最近あった出来事」「いちばんモヤモヤしていること」。<br>
      雑でもいいので、頭の中にあることをそのまま書いてくれれば大丈夫です。<br><br>
      文章が苦手なら、<br>
      「友達の友達／マッチングアプリ」「何回会ったか」「今の距離感」だけでもOKです。
    </p>
    <p class="chat-intro-note">
      ※ ここで入力した内容はブラウザ上のテスト用です。<br>
      本番環境では、プライバシーに配慮した形で送信されるよう実装します。
    </p>
  </section>

  <section>
    <div class="chat-card" id="chat-card">
      <div class="small">
        ここからは恋愛仙人とのチャットじゃ。選択肢を押すか、下の入力欄にそのまま書いてくれればよいぞ。
      </div>

      <div id="chat" class="chat-box"></div>
      <div id="step-hint" class="small step-hint"></div>
      <div id="choices" class="choices"></div>

      <div class="composer">
        <input id="free-input" class="chat-input" placeholder="自由入力はこちら（選択肢がない時や補足に）。" />
        <button id="send" class="chat-send-btn" type="button">送信</button>
      </div>

      <div id="status" class="small muted"></div>
    </div>
  </section>
</main>

<script>
/* ===========================
   1) DOM
   =========================== */
const chat        = document.getElementById("chat");
const choicesWrap = document.getElementById("choices");
const freeInput   = document.getElementById("free-input");
const sendBtn     = document.getElementById("send");
const statusEl    = document.getElementById("status");
const stepHint    = document.getElementById("step-hint");

function addAssistant(text){
  const row = document.createElement("div");
  row.className = "row assistant";
  const b = document.createElement("div");
  b.className = "bubble";
  b.textContent = String(text ?? "");
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop = chat.scrollHeight;
}

function addAssistantStreamBubble(initialText=""){
  const row = document.createElement("div");
  row.className = "row assistant";
  const b = document.createElement("div");
  b.className = "bubble";
  b.textContent = initialText;
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop = chat.scrollHeight;
  return b;
}

function addUser(text){
  const row = document.createElement("div");
  row.className = "row user";
  const b = document.createElement("div");
  b.className = "bubble";
  b.textContent = text;
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop = chat.scrollHeight;
}

/* ===========================
   1.5) Token（Stripe紐づけ）: 追加
   =========================== */
function makeToken(){
  if (window.crypto?.randomUUID) return crypto.randomUUID();
  return "tok_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
}

function saveSessionByToken(token, payload){
  // payload: { summaryJson, profile, history }
  try {
    localStorage.setItem("koi_token", token);
    localStorage.setItem(`koi_summaryJson_${token}`, JSON.stringify(payload.summaryJson ?? null));
    localStorage.setItem(`koi_profile_${token}`, JSON.stringify(payload.profile ?? null));
    localStorage.setItem(`koi_history_${token}`, JSON.stringify(payload.history ?? null));
    localStorage.setItem(`koi_createdAt_${token}`, String(Date.now()));
  } catch (e) {
    console.warn("localStorage save failed:", e);
  }
}

async function startCheckout(token){
  // サーバ側で /api/create-checkout-session を実装している想定
  // { token } を受けて Stripe の Checkout URL を返す
  const res = await fetch("/api/create-checkout-session", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ token })
  });

  const text = await res.text();
  if (!res.ok) {
    console.log("create-checkout-session error:", res.status, text);
    throw new Error("CHECKOUT_ERROR");
  }

  const data = JSON.parse(text);
  if (!data?.url) throw new Error("CHECKOUT_URL_MISSING");
  window.location.href = data.url;
}

/* ===========================
   2) 選択肢 & タイプ定義
   =========================== */
const MBTI_LIST = [
  "INFJ","INFP","ENFP","ENFJ",
  "INTJ","INTP","ENTP","ENTJ",
  "ISFJ","ISFP","ESFP","ESFJ",
  "ISTJ","ISTP","ESTP","ESTJ",
  "わからない"
];
const LOVE16_LIST = [
  "ボス猫","隠れベイビー","主役体質","ツンデレヤンキー",
  "憧れの先輩","カリスマバランサー","パーフェクトカメレオン","キャプテンライオン",
  "ロマンスマジシャン","ちゃっかりうさぎ","恋愛モンスター","忠犬ハチ公",
  "不思議生命体","敏腕マネージャー","デビル天使","最後の恋人",
  "わからない"
];
const GENDER        = ["女性","男性","その他／答えたくない"];
const TARGET_GENDER = ["女性","男性","どちらも／決めていない"];
const MEETING       = ["学校","会社","アプリ","友人紹介","その他"];

// MBTI 定義
const MBTI_DEF = {
  ISTJ:{code:"ISTJ",jp:"管理者タイプ",summary:"事実と実務に強く、責任感が強い堅実派。ルールと安定を重視しやすい。"},
  ISFJ:{code:"ISFJ",jp:"擁護者タイプ",summary:"面倒見がよく、裏方で支えるのが得意。人の気持ちと実務の両方に気を配る。"},
  INFJ:{code:"INFJ",jp:"提唱者タイプ",summary:"価値観ベースで物事を考える理想主義者。少人数を深く大事にしがち。"},
  INTJ:{code:"INTJ",jp:"戦略家タイプ",summary:"長期戦略や構造を組むのが得意。合理性重視で、感情表現は控えめ。"},
  ISTP:{code:"ISTP",jp:"職人タイプ",summary:"観察力が高く、手を動かして試すのが好き。マイペースで自由度を求める。"},
  ISFP:{code:"ISFP",jp:"アーティストタイプ",summary:"今この瞬間の心地よさや美意識に敏感。衝突を避け、柔らかく距離を取る。"},
  INFP:{code:"INFP",jp:"仲介者タイプ",summary:"内面の理想と物語世界が濃い。共感性が高く、傷つきやすさも抱えやすい。"},
  INTP:{code:"INTP",jp:"論理学者タイプ",summary:"仕組みや原理を考えるのが好き。距離を取りつつ頭の中で検証しがち。"},
  ESTP:{code:"ESTP",jp:"起業家タイプ",summary:"行動が早く、現場感覚に強い。スリルや駆け引きを楽しみやすい。"},
  ESFP:{code:"ESFP",jp:"エンターテイナータイプ",summary:"その場を明るくする盛り上げ役。五感と感情の「楽しい」を大事にする。"},
  ENFP:{code:"ENFP",jp:"広報運動家タイプ",summary:"アイデアと人への興味が強い。熱くなりやすく、気持ちで動く場面が多い。"},
  ENTP:{code:"ENTP",jp:"討論者タイプ",summary:"議論や発想ゲームが好き。可能性を広げるのは得意だが、飽きやすい面も。"},
  ESTJ:{code:"ESTJ",jp:"幹部タイプ",summary:"秩序と結果を重視する現場リーダー。決める・進める役を担いやすい。"},
  ESFJ:{code:"ESFJ",jp:"領事タイプ",summary:"対人配慮と実務の両方をこなす世話役。周囲の期待に応えようと頑張りがち。"},
  ENFJ:{code:"ENFJ",jp:"主人公タイプ",summary:"人を巻き込み、成長させるのが得意なリーダー。感情面の空気もよく読む。"},
  ENTJ:{code:"ENTJ",jp:"指揮官タイプ",summary:"目標達成に向けて組織を動かす指揮官。合理性と成果を最優先しやすい。"}
};

// 恋愛16タイプ定義
const LOVE16_DEF = {
  "ボス猫":         {code:"LCRO",summary:"超マイペースで自分軸が強い。恋愛も安定志向だが、内面は意外と繊細。"},
  "隠れベイビー":   {code:"LCRE",summary:"表面はまじめでしっかり者だが、内側は甘えたい不器用さん。信頼すると一気にデレる。"},
  "主役体質":       {code:"LCPO",summary:"場の中心に立ちやすいムードメーカー。恋愛も盛り上げてなんぼと思いがち。"},
  "ツンデレヤンキー":{code:"LCPE",summary:"口や態度は強めだが情は厚い。素直に甘えられず、ギャップで好かれやすい。"},
  "憧れの先輩":     {code:"LARO",summary:"落ち着きと大人感があり、頼られポジションが多い。さりげなく面倒を見る。"},
  "カリスマバランサー":{code:"LARE",summary:"人を導きつつ全体の調和も取るリーダー格。恋愛でも空気と公平感をかなり意識する。"},
  "パーフェクトカメレオン":{code:"LAPO",summary:"状況適応力が高い器用タイプ。相手や場に合わせてキャラを変えられる。"},
  "キャプテンライオン":{code:"LAPE",summary:"面倒見がよく、守ってくれる安心感の塊。厳しさと優しさを両立する親分肌。"},
  "ロマンスマジシャン":{code:"FCRO",summary:"距離感を測るのがうまく、雰囲気作りも得意。さらっとロマンチックなことをする観察系。"},
  "ちゃっかりうさぎ":{code:"FCRE",summary:"人懐っこいのに冷静さもある。甘え上手・愛され上手で、危機察知も鋭い。"},
  "恋愛モンスター": {code:"FCPO",summary:"感情表現が大きく、恋に一直線で走りがち。ノリと熱量で突破するタイプ。"},
  "忠犬ハチ公":     {code:"FCPE",summary:"一途でまっすぐ。好きになった相手をとことん支えようとする献身型。"},
  "不思議生命体":   {code:"FARO",summary:"一見普通だが、価値観や感性が独特。マイワールドを持ちつつ協調もできる。"},
  "敏腕マネージャー":{code:"FARE",summary:"裏方で支えるのが得意。状況把握と段取りが上手で、頼られることが多い。"},
  "デビル天使":     {code:"FAPO",summary:"基本は優しいが、自由さや小悪魔っぽさも併せ持つ二面性キャラ。"},
  "最後の恋人":     {code:"FAPE",summary:"包容力と誠実さが強い。深く寄り添い、長期的な関係を本気で望むタイプ。"}
};

const profile = {
  name:"", gender:"",
  selfMBTI:"", selfLove:"",
  targetGender:"", targetMBTI:"", targetLove:"",
  ageRange:"", status:"", relation:"",
  meeting:"", known:"", contact:"",
  worry:"", mental:"",
  style:"1"
};

/* ===========================
   3) ステップ定義（インテーク）
   =========================== */
const steps = [
  { key:"name",        kind:"input",  ask:`よく来てくれたな。恋愛仙人じゃ。まずはおぬしの名前を教えておくれ` },
  { key:"gender",      kind:"choice", ask:(p)=>`${p.name}、よろしくのう。性別はどれじゃ？`, choices:GENDER },
  { key:"selfMBTI",    kind:"choice", ask:`お主のMBTIはどれじゃ？`,                           choices:MBTI_LIST },
  { key:"selfLove",    kind:"choice", ask:`お主の恋愛16タイプは？`,                           choices:LOVE16_LIST },
  { key:"targetGender",kind:"choice", ask:`恋愛対象の性別は？`,                               choices:TARGET_GENDER },
  { key:"targetMBTI",  kind:"choice", ask:`相手のMBTIが分かれば教えてくれ`,                   choices:MBTI_LIST },
  { key:"targetLove",  kind:"choice", ask:`相手の恋愛16タイプは分かるかの？`,                 choices:LOVE16_LIST },
  { key:"ageRange",    kind:"input",  ask:`お主の年齢レンジを教えてくれ（例：20〜22）` },
  { key:"status",      kind:"input",  ask:`学生／社会人などの状態は？（例：社会人1〜3年目）` },
  { key:"relation",    kind:"input",  ask:`関係性は？（例：片思い／交際◯ヶ月／元カノ など）` },
  { key:"meeting",     kind:"choice", ask:`出会い方は？`,                                     choices:MEETING },
  { key:"known",       kind:"input",  ask:`知り合ってどれくらい？（例：1〜3ヶ月）` },
  { key:"contact",     kind:"input",  ask:`連絡頻度と、どちらからが多い？（例：2〜3日に1回／送るのは：自分からが多い）` },
  { key:"worry",       kind:"input",  ask:`いちばん悩んでいるポイントを1〜2行でそのまま書いてくれ` },
  { key:"mental",      kind:"input",  ask:`今の心の状態は？（例：不安はあるが日常は回る）` },
  { key:"style",       kind:"choice", ask:`相談スタイルを選んでくれ。`, choices:["1) もやもや整理したい","2) 今後のアクションを決めたい"] }
];

let idx = 0;

// LLM用の history
const history = [];

// 会話の状態（タイプ要約など）
const dialogState = {
  selfSummary: "",
  partnerSummary: "",
  dialogSummary: "",
  questionTheme: ""
};

function getAssistantTurn() {
  return history.filter(m => m.role === "assistant").length + 1;
}
function getPhaseFromTurn(turn) {
  if (turn <= 3) return "F";
  if (turn <= 5) return "P";
  return "D";
}
function getQuestionTheme(phase) {
  if (phase === "F") return "今いちばんしんどいと感じていそうなポイント";
  if (phase === "P") return "相手はなぜ今のような動きをしているのかについての直感";
  return "今この恋をどう進めたいと思っているかについての本音";
}

let isBusy = false;

// ※ 元コードに合わせて 8 ターンで「有料導線へ」
// （ここでは“自動で有料レポート生成”はせず、Stripeに繋ぐ）
const MAX_TURNS = 8;
let paywallPrepared = false; // 有料導線を一度だけ出す
let isFinished = false;

function setBusy(flag){
  isBusy = flag;
  sendBtn.disabled = flag;
  freeInput.disabled = flag;
  const choiceBtns = choicesWrap.querySelectorAll("button.choice");
  choiceBtns.forEach(btn => btn.disabled = flag);
}

/* ===========================
   4) インテーク回答処理
   =========================== */
async function onAnswer(valueRaw){
  if (isBusy) return;
  setBusy(true);

  const s = steps[idx];
  const value = String(valueRaw).trim();
  if (!value){
    setBusy(false);
    return;
  }

  try {
    if (s.key === "style") {
      profile.style = value.startsWith("2") ? "2" : "1";
    } else {
      profile[s.key] = value;
    }

    addUser(value);

    const choiceBtns = choicesWrap.querySelectorAll("button.choice");
    choiceBtns.forEach(btn => btn.disabled = true);

    await quickAcknowledge(s.key, value);

    idx++;
    if (idx < steps.length) {
      setBusy(false);
      showAsk();
    } else {
      statusEl.textContent = "仙人が考え中じゃ…";
      await startFirstTurn();
      statusEl.textContent = "";
      setBusy(false);
    }

  } catch(e){
    console.warn("onAnswer error:", e);
    addAssistant("少し調子が悪いようじゃ…もう一度試してくれるかのう。");
    setBusy(false);
  }
}

/* ===========================
   5) インテーク時の一言コメント（元コード踏襲）
   =========================== */
async function quickAcknowledge(key, value){
  // ここは元のロジックをそのまま残す（必要最低限のフォールバックだけ）
  const map = {
    name:        `よし、${value}と呼ぶぞ。肩の力を抜いて話してええのう。`,
    gender:      `受け取ったぞ。`,
    selfMBTI:    `了解じゃ。タイプ感は頭に入れておくのう。`,
    selfLove:    `ふむ、覚えておくぞい。`,
    targetGender:`なるほどのう。`,
    targetMBTI:  `相手のタイプも頭に入れておくぞ。`,
    targetLove:  `相手の恋愛気質も理解したぞい。`,
    ageRange:    `うむ、ありがとう。`,
    status:      `うむ、状況レンジもOKじゃ。`,
    relation:    `了解じゃ。`,
    meeting:     `うむ。`,
    known:       `ふむふむ。`,
    contact:     `受け取った。`,
    worry:       `うむ…後ほどここを深掘りしよう。`,
    mental:      `なるほどのう。`,
    style:       (value.startsWith("2")
                 ? `了解、今回は「方針決め」寄りで進めるぞ。`
                 : `了解、まずは気持ちの整理を優先じゃ。`)
  };
  if (map[key]) addAssistant(map[key]);
}

/* ===========================
   6) 質問表示（インテーク）
   =========================== */
function showAsk(){
  choicesWrap.innerHTML = "";
  freeInput.value = "";
  const s = steps[idx];
  const text = typeof s.ask === "function" ? s.ask(profile) : s.ask;
  addAssistant(text);

  if (s.kind === "choice") {
    (s.choices || []).forEach(label=>{
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.textContent = label;
      btn.addEventListener("click", () => onAnswer(label));
      choicesWrap.appendChild(btn);
    });
    stepHint.textContent = "選択肢を押すか、下の自由入力でも回答できるぞ。";
  } else {
    stepHint.textContent = "下の入力欄に書いて『送信』じゃ。";
  }
}

/* ===========================
   7) OpenAI 呼び出し（/api/chat 経由）
   =========================== */
async function callOpenAI(messages){
  const res = await fetch("/api/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ messages }),
  });

  const text = await res.text();
  console.log("=== /api/chat raw response ===");
  console.log("status:", res.status);
  console.log("body:", text);

  if (!res.ok) throw new Error("API_ERROR");

  const data = JSON.parse(text);
  return data.content || "";
}

/* ===========================
   8) system（ここは元コードの巨大テンプレを使う前提）
   ただしこの貼り付けでは省略せず、最低限動く形の簡易版にしています。
   （あなたの元テンプレを使う場合は、下のCOMMON_SYS等を差し替えてください）
   =========================== */
const COMMON_SYS = `あなたは「恋脳レポート」の恋愛仙人じゃ。一人称は「わし」。ユーザは「お主」かニックネームで呼ぶ。敬語は禁止じゃ。`;
const SYS_PHASE_F = `今は感情の整理が主じゃ。行動提案は控えるのじゃ。`;
const SYS_PHASE_P = `相手の動き方を“傾向”として考えるのじゃ。断定はするな。`;
const SYS_PHASE_D = `本音の距離感とペースを言葉にするのじゃ。`;

function buildCommonSystem(p){
  return COMMON_SYS.replaceAll("ニックネーム", p.name || "お主");
}
function buildPhaseSystem(phase){
  if (phase === "F") return SYS_PHASE_F;
  if (phase === "P") return SYS_PHASE_P;
  return SYS_PHASE_D;
}

function initDialogSummary(){
  dialogState.dialogSummary =
    `関係性: ${profile.relation || "不明"} / 出会い: ${profile.meeting || "不明"} / ` +
    `悩み: ${profile.worry || "未入力"} / 心の状態: ${profile.mental || "未入力"}`;
}
function updateDialogSummary(latestUserText){
  const trimmed = latestUserText.replace(/\s+/g," ").slice(0,80);
  dialogState.dialogSummary =
    dialogState.dialogSummary + ` / ユーザ直近の発言: ${trimmed}`;
}
function buildUserMeta(phase, userText, opt){
  const meta = {
    phase,
    first_turn: !!(opt && opt.firstTurn),
    final_turn: !!(opt && opt.finalTurn),
    question_theme: dialogState.questionTheme,
    summary_so_far: dialogState.dialogSummary
  };
  return `【メタ情報】\n${JSON.stringify(meta, null, 2)}\n\n【今回のユーザ発言】\n${userText}`;
}

/* ===========================
   10) 初回応答
   =========================== */
async function startFirstTurn(){
  initDialogSummary();
  const phase = "F";
  dialogState.questionTheme = "今いちばん強く抱いていそうな不安";

  const firstUserText =
    `いちばん悩んでいること: ${profile.worry || "未入力"}\n` +
    `今の心の状態: ${profile.mental || "未入力"}`;

  updateDialogSummary(firstUserText);

  const msgs = [
    { role:"system", content: buildCommonSystem(profile) },
    { role:"system", content: buildPhaseSystem(phase) },
    { role:"user",   content: buildUserMeta(phase, firstUserText, { firstTurn:true }) }
  ];

  try{
    const reply = await withRetry(()=>callOpenAI(msgs));
    addAssistant(reply);
    history.push({role:"user",content:msgs[2].content});
    history.push({role:"assistant",content:reply});
  }catch(e){
    console.warn("first turn error:", e);
    addAssistant("今は少し調子が悪いようじゃ…時間をおいて試してくれんかのう。");
  }
}

/* ===========================
   11) リトライ（429対策）
   =========================== */
async function withRetry(fn, max=3){
  let wait=1200;
  for (let i=0;i<max;i++){
    try{
      return await fn();
    }catch(e){
      if (e.message==="BUSY" && i<max-1){
        await new Promise(r=>setTimeout(r,wait));
        wait*=2;
        continue;
      }
      throw e;
    }
  }
}

/* ===========================
   12) 以降のやり取り（通常チャット）
   =========================== */
async function sendFree(){
  const text = freeInput.value.trim();
  if (!text) return;
  if (isBusy) return;

  // インテーク中
  if (idx < steps.length){
    await onAnswer(text);
    freeInput.value = "";
    return;
  }

  addUser(text);
  freeInput.value = "";
  setBusy(true);
  statusEl.textContent = "仙人が考え中じゃ…";

  const nextTurn = getAssistantTurn();
  const phase    = getPhaseFromTurn(nextTurn);
  dialogState.questionTheme = getQuestionTheme(phase);
  updateDialogSummary(text);

  const isFinalTurn = (nextTurn === MAX_TURNS);

  const msgs = [
    { role:"system", content: buildCommonSystem(profile) },
    { role:"system", content: buildPhaseSystem(phase) },
    ...history,
    { role:"user", content: buildUserMeta(phase, text, { firstTurn:false, finalTurn:isFinalTurn }) }
  ];

  try{
    const reply = await withRetry(()=>callOpenAI(msgs));
    addAssistant(reply);
    history.push({role:"user",content:msgs[msgs.length-1].content});
    history.push({role:"assistant",content:reply});

    // ★ここが改修点(2)：MAX_TURNS で Stripe導線へ（自動生成はしない）
    if (nextTurn === MAX_TURNS && !paywallPrepared) {
      await preparePaidFlow();
    }

  }catch(e){
    console.warn("chat error:", e);
    addAssistant("今は他の人の相談に乗っておってな、少し時間をおいてからもう一度頼むのじゃ。");
  }finally{
    statusEl.textContent = "";
    setBusy(false);
  }
}

/* ===========================
   13) Stripe用の「有料導線」準備：追加
   - summaryJson を生成
   - token を発行して localStorage に保存
   - Checkout に遷移するボタンを出す
   =========================== */
async function preparePaidFlow(){
  if (paywallPrepared) return;
  paywallPrepared = true;

  statusEl.textContent = "仙人がまとめを用意しておる…";

  try {
    // 1) summaryJson（設計図）を作る
    const summaryResp = await fetch("/api/paid-summary", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ profile, history }),
    });

    const raw = await summaryResp.text();
    if (!summaryResp.ok) {
      console.log("paid-summary error:", summaryResp.status, raw);
      paywallPrepared = false;
      addAssistant("サマリー生成でエラーが出てしもうた…。もう一度試してくれんかのう。");
      return;
    }

    const summaryJson = JSON.parse(raw);

    // 2) token発行 → 保存（token不一致対策の本体）
    const token = makeToken();
    saveSessionByToken(token, { summaryJson, profile, history });

    // 3) UI：購入ボタンを表示
    addAssistant("よし、ここまでの内容で『有料レポート』を作れる下準備は整ったぞ。続き（レポート生成）は購入後に進めるのじゃ。");

    choicesWrap.innerHTML = "";

    const buyBtn = document.createElement("button");
    buyBtn.className = "choice";
    buyBtn.textContent = "購入してレポートを作る（Stripe）";
    buyBtn.addEventListener("click", async () => {
      try {
        setBusy(true);
        statusEl.textContent = "決済画面へ移動中じゃ…";
        await startCheckout(token);
      } catch (e) {
        console.warn(e);
        addAssistant("決済ページへの遷移で失敗したようじゃ…。/api/create-checkout-session を確認してくれんかのう。");
      } finally {
        statusEl.textContent = "";
        setBusy(false);
      }
    });

    const laterBtn = document.createElement("button");
    laterBtn.className = "choice secondary";
    laterBtn.textContent = "今は購入しない（ここで終了）";
    laterBtn.addEventListener("click", () => {
      addAssistant("了解じゃ。必要になったらまた来るがよいぞ。");
      // ここではロックしない（好きに読み返せる）
      sendBtn.disabled = true;
      freeInput.disabled = true;
      freeInput.placeholder = "購入する場合はページを再読み込みして、最後まで進めてくれ。";
      stepHint.textContent = "";
    });

    // 任意：購入後に飛ぶページが report.html で token をクエリに乗せるなら使える
    const openReportBtn = document.createElement("button");
    openReportBtn.className = "choice secondary";
    openReportBtn.textContent = "購入済みならレポート表示（token付き）";
    openReportBtn.addEventListener("click", () => {
      // report.html 側で token を見て localStorage の koi_summaryJson_{token} を使う想定
      window.location.href = `report.html?token=${encodeURIComponent(token)}`;
    });

    choicesWrap.appendChild(buyBtn);
    choicesWrap.appendChild(openReportBtn);
    choicesWrap.appendChild(laterBtn);

    // 4) 入力は止める（勝手に次へ進めない）
    sendBtn.disabled = true;
    freeInput.disabled = true;
    freeInput.placeholder = "ここまでで無料パートは完了じゃ。購入ボタンから進めてくれ。";
    stepHint.textContent = "";

  } catch (e) {
    console.error(e);
    paywallPrepared = false;
    addAssistant("うまく下準備ができんかった…。少し時間をおいて試してくれんか。");
  } finally {
    statusEl.textContent = "";
  }
}

/* ===========================
   14) イベント & 起動：改修(1)「クリック送信のみ」
   =========================== */

// クリックで送信（onclick 代入は使わない）
sendBtn.addEventListener("click", (e) => {
  e.preventDefault();
  sendFree();
});

// Enter では送信しない（IME確定のEnterも邪魔しない）
freeInput.addEventListener("keydown", (e) => {
  if (e.key !== "Enter") return;
  if (e.isComposing) return;  // 変換確定中は許可
  e.preventDefault();         // 変換中でないEnterは無効化（送信もしない）
});

(function boot(){
  showAsk();
})();
</script>
</body>
</html>
