<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>恋ぐるラボ｜恋愛仙人チャット</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #fff7f8;
      --card: #ffffff;
      --ink: #111827;
      --muted: #6b7280;
      --accent: #f97373;
      --accent-dark: #e45454;
      --line: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Yu Gothic", "YuGothic",
        system-ui, "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at top left, #ffe6ec, #fff7f8 40%, #ffffff 80%);
    }

    /* ヘッダー（indexとほぼ共通） */
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(229, 231, 235, 0.7);
    }
    .header-inner {
      max-width: 960px;
      margin: 0 auto;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .logo-mark {
      width: 32px;
      height: 32px;
      border-radius: 12px;
      background: linear-gradient(135deg, #f97373, #fb7185);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 18px;
      font-weight: 700;
    }
    .logo-text-main {
      font-weight: 700;
      letter-spacing: 0.05em;
      font-size: 16px;
    }
    .logo-text-sub {
      font-size: 11px;
      color: var(--muted);
      border: 1px solid #fecaca;
      border-radius: 999px;
      padding: 2px 8px;
      margin-left: 4px;
      background: #fff7f7;
    }
    .header-nav {
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
    }
    .header-link {
      color: var(--muted);
      text-decoration: none;
      padding: 4px 0;
    }
    .header-link:hover {
      color: var(--ink);
    }
    .header-cta {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(249, 115, 115, 0.35);
    }
    .header-cta:hover {
      background: var(--accent-dark);
    }

    .chat-layout {
      max-width: 960px;
      margin: 0 auto;
      padding: 32px 16px 40px;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 28px;
      /* 追加：ヘッダーを引いた分だけ縦を確保 */
      min-height: calc(100vh - 80px);
    }
    @media (max-width: 800px) {
      .chat-layout {
        grid-template-columns: minmax(0, 1fr);
        padding-top: 20px;
      }
    }

    .chat-intro-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 12px;
      line-height: 1.6;
    }
    .chat-intro-lead {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.8;
      margin-bottom: 18px;
    }
    .chat-intro-note {
      font-size: 12px;
      color: var(--muted);
      margin-top: 12px;
    }

    /* チャットカード（右側コンテナ） */
    .chat-card {
      background: var(--card);
      border-radius: 20px;
      padding: 14px 12px;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
      border: 1px solid rgba(248, 113, 113, 0.25);
      display: flex;
      flex-direction: column;
      /* ここから変更点 ↓ */
      height: calc(100vh - 160px); /* 画面高ベースでかなり大きく */
      max-height: none;
    }

    /* スマホ時は少しだけ低めに調整 */
    @media (max-width: 800px) {
      .chat-card {
        height: calc(100vh - 200px);
      }
    }

    /* ここから下は「仙人チャット頭脳」用のスタイル追加分 */

    .small {
      color: var(--muted);
      font-size: 12px;
    }

    .step-hint {
      margin-top: 6px;
    }

    .chat-box {
      height: 100%;
      overflow-y: auto;
      border-radius: 14px;
      background: #fef2f2;
      padding: 8px;
      border: 1px solid #ffe4e6;
      margin-top: 6px;
      /* 追加：flex で縦に伸ばす */
      flex: 1 1 auto;
      min-height: 0;
    }

    .row {
      display: flex;
      margin: 6px 0;
    }
    .row .bubble {
      max-width: 82%;
      padding: 8px 10px;
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
      line-height: 1.7;
    }
    .row.assistant {
      justify-content: flex-start;
    }
    .row.assistant .bubble {
      background: #ffffff;
      color: #111827;
      border-bottom-left-radius: 4px;
    }
    .row.user {
      justify-content: flex-end;
    }
    .row.user .bubble {
      background: #f97373;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .choices {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .choice {
      appearance: none;
      border: none;
      background: #111827;
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
    }
    .choice.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    .choice:focus {
      outline: 3px solid #fecaca;
    }

    .composer {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      align-items: center;
    }

    .composer input {
      flex: 1;
    }

    .muted {
      color: var(--muted);
    }

    /* 既存の入力系スタイルを再利用 */
    .chat-input {
      width: 100%;
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #fecaca;
      outline: none;
      font-family: inherit;
    }
    .chat-input:focus {
      border-color: #fb7185;
      box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.2);
    }

    .chat-send-btn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }
    .chat-send-btn:hover {
      background: var(--accent-dark);
    }
    .chat-send-btn[disabled] {
      opacity: 0.6;
      cursor: default;
    }
  </style>
</head>
<body>

<header>
  <div class="header-inner">
    <div class="logo">
      <div class="logo-mark">恋</div>
      <div>
        <div class="logo-text-main">恋ぐるラボ</div>
        <span class="logo-text-sub">恋愛仙人チャット</span>
      </div>
    </div>
    <nav class="header-nav">
      <a href="index.html" class="header-link">トップに戻る</a>
      <button class="header-cta" onclick="window.location.href='index.html'">
        LPを見る
      </button>
    </nav>
  </div>
</header>

<main class="chat-layout">
  <!-- 左：説明 -->
  <section>
    <h1 class="chat-intro-title">
      恋愛仙人に、今の状況をそのまま話してみてください。
    </h1>
    <p class="chat-intro-lead">
      「相手との関係」「最近あった出来事」「いちばんモヤモヤしていること」。<br>
      雑でもいいので、頭の中にあることをそのまま書いてくれれば大丈夫です。<br><br>
      文章が苦手なら、<br>
      「友達の友達／マッチングアプリ」「何回会ったか」「今の距離感」だけでもOKです。
    </p>
    <p class="chat-intro-note">
      ※ ここで入力した内容はブラウザ上のテスト用です。<br>
      本番環境では、プライバシーに配慮した形で送信されるよう実装します。
    </p>
  </section>

  <!-- 右：チャットUI（仙人本番ロジック用DOMだけ残す） -->
  <section>
    <div class="chat-card" id="chat-card">
      <div class="small">
        ここからは恋愛仙人とのチャットじゃ。選択肢を押すか、下の入力欄にそのまま書いてくれればよいぞ。
      </div>
      <!-- メッセージ表示エリア -->
      <div id="chat" class="chat-box"></div>

      <!-- ステップのヒント -->
      <div id="step-hint" class="small step-hint"></div>

      <!-- 選択肢ボタン -->
      <div id="choices" class="choices"></div>

      <!-- 自由入力 ＋ 送信ボタン -->
      <div class="composer">
        <input
          id="free-input"
          class="chat-input"
          placeholder="自由入力はこちら（選択肢がない時や補足に）。"
        />
        <button id="send" class="chat-send-btn">送信</button>
      </div>

      <!-- ステータス表示 -->
      <div id="status" class="small muted"></div>
    </div>
  </section>
</main>

<script>

/* ===========================
   1) DOM
   =========================== */
const chat       = document.getElementById("chat");
const choicesWrap= document.getElementById("choices");
const freeInput  = document.getElementById("free-input");
const sendBtn    = document.getElementById("send");
const statusEl   = document.getElementById("status");
const stepHint   = document.getElementById("step-hint");

function addAssistant(text){
  const row=document.createElement("div");
  row.className="row assistant";
  const b=document.createElement("div");
  b.className="bubble";
  b.textContent=String(text ?? "");
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop=chat.scrollHeight;
}

function addAssistantStreamBubble(initialText=""){
  const row=document.createElement("div");
  row.className="row assistant";
  const b=document.createElement("div");
  b.className="bubble";
  b.textContent=initialText;
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop=chat.scrollHeight;
  return b; // このbubbleに追記していく
}

function addUser(text){
  const row=document.createElement("div");
  row.className="row user";
  const b=document.createElement("div");
  b.className="bubble";
  b.textContent=text;
  row.appendChild(b);
  chat.appendChild(row);
  chat.scrollTop=chat.scrollHeight;
}

/* ===========================
   2) 選択肢 & タイプ定義
   =========================== */
const MBTI_LIST = [
  "INFJ","INFP","ENFP","ENFJ",
  "INTJ","INTP","ENTP","ENTJ",
  "ISFJ","ISFP","ESFP","ESFJ",
  "ISTJ","ISTP","ESTP","ESTJ",
  "わからない"
];
const LOVE16_LIST = [
  "ボス猫","隠れベイビー","主役体質","ツンデレヤンキー",
  "憧れの先輩","カリスマバランサー","パーフェクトカメレオン","キャプテンライオン",
  "ロマンスマジシャン","ちゃっかりうさぎ","恋愛モンスター","忠犬ハチ公",
  "不思議生命体","敏腕マネージャー","デビル天使","最後の恋人",
  "わからない"
];
const GENDER        = ["女性","男性","その他／答えたくない"];
const TARGET_GENDER = ["女性","男性","どちらも／決めていない"];
const MEETING       = ["学校","会社","アプリ","友人紹介","その他"];

// MBTI 定義
const MBTI_DEF = {
  ISTJ:{code:"ISTJ",jp:"管理者タイプ",summary:"事実と実務に強く、責任感が強い堅実派。ルールと安定を重視しやすい。"},
  ISFJ:{code:"ISFJ",jp:"擁護者タイプ",summary:"面倒見がよく、裏方で支えるのが得意。人の気持ちと実務の両方に気を配る。"},
  INFJ:{code:"INFJ",jp:"提唱者タイプ",summary:"価値観ベースで物事を考える理想主義者。少人数を深く大事にしがち。"},
  INTJ:{code:"INTJ",jp:"戦略家タイプ",summary:"長期戦略や構造を組むのが得意。合理性重視で、感情表現は控えめ。"},
  ISTP:{code:"ISTP",jp:"職人タイプ",summary:"観察力が高く、手を動かして試すのが好き。マイペースで自由度を求める。"},
  ISFP:{code:"ISFP",jp:"アーティストタイプ",summary:"今この瞬間の心地よさや美意識に敏感。衝突を避け、柔らかく距離を取る。"},
  INFP:{code:"INFP",jp:"仲介者タイプ",summary:"内面の理想と物語世界が濃い。共感性が高く、傷つきやすさも抱えやすい。"},
  INTP:{code:"INTP",jp:"論理学者タイプ",summary:"仕組みや原理を考えるのが好き。距離を取りつつ頭の中で検証しがち。"},
  ESTP:{code:"ESTP",jp:"起業家タイプ",summary:"行動が早く、現場感覚に強い。スリルや駆け引きを楽しみやすい。"},
  ESFP:{code:"ESFP",jp:"エンターテイナータイプ",summary:"その場を明るくする盛り上げ役。五感と感情の「楽しい」を大事にする。"},
  ENFP:{code:"ENFP",jp:"広報運動家タイプ",summary:"アイデアと人への興味が強い。熱くなりやすく、気持ちで動く場面が多い。"},
  ENTP:{code:"ENTP",jp:"討論者タイプ",summary:"議論や発想ゲームが好き。可能性を広げるのは得意だが、飽きやすい面も。"},
  ESTJ:{code:"ESTJ",jp:"幹部タイプ",summary:"秩序と結果を重視する現場リーダー。決める・進める役を担いやすい。"},
  ESFJ:{code:"ESFJ",jp:"領事タイプ",summary:"対人配慮と実務の両方をこなす世話役。周囲の期待に応えようと頑張りがち。"},
  ENFJ:{code:"ENFJ",jp:"主人公タイプ",summary:"人を巻き込み、成長させるのが得意なリーダー。感情面の空気もよく読む。"},
  ENTJ:{code:"ENTJ",jp:"指揮官タイプ",summary:"目標達成に向けて組織を動かす指揮官。合理性と成果を最優先しやすい。"}
};

// 恋愛16タイプ定義
const LOVE16_DEF = {
  "ボス猫":         {code:"LCRO",summary:"超マイペースで自分軸が強い。恋愛も安定志向だが、内面は意外と繊細。"},
  "隠れベイビー":   {code:"LCRE",summary:"表面はまじめでしっかり者だが、内側は甘えたい不器用さん。信頼すると一気にデレる。"},
  "主役体質":       {code:"LCPO",summary:"場の中心に立ちやすいムードメーカー。恋愛も盛り上げてなんぼと思いがち。"},
  "ツンデレヤンキー":{code:"LCPE",summary:"口や態度は強めだが情は厚い。素直に甘えられず、ギャップで好かれやすい。"},
  "憧れの先輩":     {code:"LARO",summary:"落ち着きと大人感があり、頼られポジションが多い。さりげなく面倒を見る。"},
  "カリスマバランサー":{code:"LARE",summary:"人を導きつつ全体の調和も取るリーダー格。恋愛でも空気と公平感をかなり意識する。"},
  "パーフェクトカメレオン":{code:"LAPO",summary:"状況適応力が高い器用タイプ。相手や場に合わせてキャラを変えられる。"},
  "キャプテンライオン":{code:"LAPE",summary:"面倒見がよく、守ってくれる安心感の塊。厳しさと優しさを両立する親分肌。"},
  "ロマンスマジシャン":{code:"FCRO",summary:"距離感を測るのがうまく、雰囲気作りも得意。さらっとロマンチックなことをする観察系。"},
  "ちゃっかりうさぎ":{code:"FCRE",summary:"人懐っこいのに冷静さもある。甘え上手・愛され上手で、危機察知も鋭い。"},
  "恋愛モンスター": {code:"FCPO",summary:"感情表現が大きく、恋に一直線で走りがち。ノリと熱量で突破するタイプ。"},
  "忠犬ハチ公":     {code:"FCPE",summary:"一途でまっすぐ。好きになった相手をとことん支えようとする献身型。"},
  "不思議生命体":   {code:"FARO",summary:"一見普通だが、価値観や感性が独特。マイワールドを持ちつつ協調もできる。"},
  "敏腕マネージャー":{code:"FARE",summary:"裏方で支えるのが得意。状況把握と段取りが上手で、頼られることが多い。"},
  "デビル天使":     {code:"FAPO",summary:"基本は優しいが、自由さや小悪魔っぽさも併せ持つ二面性キャラ。"},
  "最後の恋人":     {code:"FAPE",summary:"包容力と誠実さが強い。深く寄り添い、長期的な関係を本気で望むタイプ。"}
};

const profile = {
  name:"", gender:"",
  selfMBTI:"", selfLove:"",
  targetGender:"", targetMBTI:"", targetLove:"",
  ageRange:"", status:"", relation:"",
  meeting:"", known:"", contact:"",
  worry:"", mental:"",
  style:"1"
};

/* ===========================
   3) ステップ定義（インテーク）
   =========================== */
const steps = [
  { key:"name",        kind:"input",  ask:`よく来てくれたな。恋愛仙人じゃ。まずはおぬしの名前を教えておくれ` },
  { key:"gender",      kind:"choice", ask:(p)=>`${p.name}、よろしくのう。性別はどれじゃ？`,                         choices:GENDER },
  { key:"selfMBTI",    kind:"choice", ask:`お主のMBTIはどれじゃ？`,                                                   choices:MBTI_LIST },
  { key:"selfLove",    kind:"choice", ask:`お主の恋愛16タイプは？`,                                                   choices:LOVE16_LIST },
  { key:"targetGender",kind:"choice", ask:`恋愛対象の性別は？`,                                                       choices:TARGET_GENDER },
  { key:"targetMBTI",  kind:"choice", ask:`相手のMBTIが分かれば教えてくれ`,                                           choices:MBTI_LIST },
  { key:"targetLove",  kind:"choice", ask:`相手の恋愛16タイプは分かるかの？`,                                         choices:LOVE16_LIST },
  { key:"ageRange",    kind:"input",  ask:`お主の年齢レンジを教えてくれ（例：20〜22）` },
  { key:"status",      kind:"input",  ask:`学生／社会人などの状態は？（例：社会人1〜3年目）` },
  { key:"relation",    kind:"input",  ask:`関係性は？（例：片思い／交際◯ヶ月／元カノ など）` },
  { key:"meeting",     kind:"choice", ask:`出会い方は？`,                                                             choices:MEETING },
  { key:"known",       kind:"input",  ask:`知り合ってどれくらい？（例：1〜3ヶ月）` },
  { key:"contact",     kind:"input",  ask:`連絡頻度と、どちらからが多い？（例：2〜3日に1回／送るのは：自分からが多い）` },
  { key:"worry",       kind:"input",  ask:`いちばん悩んでいるポイントを1〜2行でそのまま書いてくれ` },
  { key:"mental",      kind:"input",  ask:`今の心の状態は？（例：不安はあるが日常は回る）` },
  { key:"style",       kind:"choice", ask:`相談スタイルを選んでくれ。`,                                               choices:["1) もやもや整理したい","2) 今後のアクションを決めたい"] }
];

let idx = 0;

// LLM用の history（メタ付き user / assistant）
const history = [];

// 会話の状態（タイプ要約など）
const dialogState = {
  selfSummary: "",
  partnerSummary: "",
  dialogSummary: "",
  questionTheme: ""
};

// assistantターン数とフェーズ判定
function getAssistantTurn() {
  return history.filter(m => m.role === "assistant").length + 1;
}

// フェーズ分け：1〜3:F, 4〜5:P, 6〜8:D
function getPhaseFromTurn(turn) {
  if (turn <= 3) return "F";
  if (turn <= 5) return "P";
  return "D";
}

// questionTheme をフェーズから決める
function getQuestionTheme(phase) {
  if (phase === "F") {
    return "今いちばんしんどいと感じていそうなポイント";
  } else if (phase === "P") {
    return "相手はなぜ今のような動きをしているのかについての直感";
  } else {
    return "今この恋をどう進めたいと思っているかについての本音";
  }
}

// API呼び出し中フラグ
let isBusy = false;

// 仙人ターン上限（LLMからの返答は9ターンまで）
const MAX_TURNS = 8;
let reportGenerated = false; //トリセツを一度だけ出すためのフラグ 
// 会話終了フラグ
let isFinished = false;

// UIロック/解除
function setBusy(flag){
  isBusy = flag;
  sendBtn.disabled   = flag;
  freeInput.disabled = flag;
  const choiceBtns = choicesWrap.querySelectorAll("button.choice");
  choiceBtns.forEach(btn => btn.disabled = flag);
}

/* ===========================
   4) インテーク回答処理
   =========================== */
async function onAnswer(valueRaw){
  if (isBusy) return;
  setBusy(true);

  const s = steps[idx];
  const value = String(valueRaw).trim();
  if (!value){
    setBusy(false);
    return;
  }

  try {
    // プロフィールに格納
    if (s.key === "style") {
      profile.style = value.startsWith("2") ? "2" : "1";
    } else {
      profile[s.key] = value;
    }

    // ユーザ側バブル
    addUser(value);

    // いま表示されている選択肢は押せなくしておく
    const choiceBtns = choicesWrap.querySelectorAll("button.choice");
    choiceBtns.forEach(btn => btn.disabled = true);

    // 一言コメント（MBTI / 恋愛16 / 相手タイプなど）
    await quickAcknowledge(s.key, value);

    // 次のステップへ
    idx++;
    if (idx < steps.length) {
      setBusy(false);
      showAsk();
    } else {
      // インテーク完了 → 初回長文生成（Fフェーズ1ターン目）
      statusEl.textContent = "仙人が考え中じゃ…";
      await startFirstTurn();
      statusEl.textContent = "";
      setBusy(false);
    }

  } catch(e){
    console.warn("onAnswer error:", e);
    addAssistant("少し調子が悪いようじゃ…もう一度試してくれるかのう。");
    setBusy(false);
  }
}

/* ===========================
   5) インテーク時の一言コメント
   =========================== */
async function quickAcknowledge(key, value){
  try {
    const me = profile.gender === "男性" ? "俺" : "私";

    // --- 自分の MBTI ---
    if (key === "selfMBTI" && MBTI_DEF[value]) {
      const d = MBTI_DEF[value];
      const msgs = [
        {
          role:"system",
          content: `
あなたは「恋脳レポート」の恋愛仙人じゃ。
一人称は「わし」。ユーザは「お主」かニックネーム（${profile.name}）で呼ぶ。
これは『お主自身』のMBTIタイプを受け取った場面じゃ。

出力条件：
・最初の1文は必ず「ほう、${d.code}か。」の形で始める。
・続く3〜5文で、下記の説明をもとに「普段の性格」と「恋愛で出やすい心のクセ」を仙人口調で占いっぽく語る。
・そのあとに、ユーザの心の中の独り言を2行、カギ括弧で出すこと。
　- 一人称は「${me}」
　- 語尾は「〜なんじゃないか…？」「〜なのかな…」「〜かもしれない…」など自然な独白
　- 仙人語（〜じゃ／〜のう）は絶対に混ぜない
・最後に1〜2文で、
　「では次に、${profile.name || "お主"}の恋愛16タイプを教えてくれ。分からなければ『わからない』でもかまわんぞ」
　という意味の文で、次の質問につなげる。
・全体でおおよそ400〜550文字程度。
・仙人側の文の文末には、「〜じゃ／〜じゃな／〜ぞ／〜のう／〜かもしれん」を適宜混ぜること。
・敬語やビジネス口調は禁止。
          `.trim()
        },
        {
          role:"user",
          content: `
MBTI: ${d.code}
日本語名: ${d.jp}
説明: ${d.summary}
          `.trim()
        }
      ];
      
      statusEl.textContent = "仙人が考え中じゃ…";

      try {
        const reply = await withRetry(()=>callOpenAI(msgs));
        addAssistant(reply.trim());
      } finally {
        statusEl.textContent = "";
      }
      return;
    }

    // --- 自分の恋愛16タイプ ---
    if (key === "selfLove" && LOVE16_DEF[value]) {
      const dLove = LOVE16_DEF[value];
      const mbti = profile.selfMBTI;
      const dMbti = mbti && MBTI_DEF[mbti] ? MBTI_DEF[mbti] : null;

      const msgs = [
        {
          role:"system",
          content: `
あなたは「恋脳レポート」の恋愛仙人じゃ。
一人称は「わし」。ユーザは「お主」かニックネーム（${profile.name}）で呼ぶ。
これは『お主自身』の恋愛16タイプを受け取った場面じゃ。

出力条件：
・最初の1文は必ず「ほう、「${value}」タイプか。」で始める。
・続く3〜4文で、この恋愛16タイプの特徴を、
　「感情の動き」「恋の入り方」「傷つきやすさ／不安の振れ幅」あたりに触れながら占いっぽく語る。
・もしMBTI情報（${mbti || "不明"}）がある場合は、
　中盤〜後半で1〜2文使って
　『${value}×${mbti}ってな、〜タイプなんじゃ。』
　のように「掛け算」で性格当てを行い、そのクセが今回の恋でどう出やすいかを述べる。
・そのあとに、ユーザの心の中の独り言を2行、カギ括弧で出すこと。
　- 一人称は「${me}」
　- 語尾は「〜なんじゃないか…？」「〜なのかな…」「〜かもしれない…」など自然な独白
　- 仙人語は混ぜない
・最後に1〜2文で、
　「${profile.name || "お主"}は情熱が強い分、反応の温度差に敏感になりやすいのう」など一言まとめつつ締める。
・全体で450〜650文字程度。
・仙人側の文の文末には、「〜じゃ／〜じゃな／〜ぞ／〜のう／〜かもしれん」を適宜混ぜること。
・敬語やビジネス口調は禁止。
          `.trim()
        },
        {
          role:"user",
          content: `
恋愛16タイプ: ${value}
タイプ説明: ${dLove.summary}
MBTI: ${dMbti ? dMbti.code : "不明"}
MBTI説明: ${dMbti ? dMbti.summary : "情報なし"}
          `.trim()
        }
      ];
      statusEl.textContent = "仙人が考え中じゃ…";

      try {
        const reply = await withRetry(()=>callOpenAI(msgs));
        addAssistant(reply.trim());
      } finally {
        statusEl.textContent = "";
      }
      return;
    }

    // --- 相手の MBTI ---
    if (key === "targetMBTI" && MBTI_DEF[value]) {
      const d = MBTI_DEF[value];
      const targetLabel =
        profile.targetGender === "男性" ? "男性" :
        profile.targetGender === "女性" ? "女性" : "相手";

      const msgs = [
        {
          role:"system",
          content: `
あなたは「恋脳レポート」の恋愛仙人じゃ。
一人称は「わし」。ユーザは「お主」かニックネーム（${profile.name}）で呼ぶ。
これは『相手』のMBTIタイプを受け取った場面じゃ。

出力条件：
・最初の文は必ず「承知したぞ。${d.code}（${d.jp}）の${targetLabel}とな。」の形で始める。
・続く3〜4文で、このタイプの
　「行動の速さ／慎重さ」「恋愛でのテンポ」「感情の出し方」などを仙人目線で占いっぽく語る。
・その中で1文は、お主目線での感じ方に軽く触れてよい。
・最後の1〜2文で、
　「では次に、その相手の恋愛16タイプが分かるようなら教えてくれ。わからなければ『わからない』でよいぞ」
　という意味の文で、次の質問につなげる。
・全体で300〜450文字程度。
・仙人側の文の文末には、「〜じゃ／〜じゃな／〜ぞ／〜のう／〜かもしれん」を適宜混ぜること。
・敬語やビジネス口調は禁止。
          `.trim()
        },
        {
          role:"user",
          content: `
相手のMBTI: ${d.code}
日本語名: ${d.jp}
説明: ${d.summary}
          `.trim()
        }
      ];
      statusEl.textContent = "仙人が考え中じゃ…";

      try {
        const reply = await withRetry(()=>callOpenAI(msgs));
        addAssistant(reply.trim());
      } finally {
        statusEl.textContent = "";
      }
      return;
    }

    // --- 相手の恋愛16タイプ ---
    if (key === "targetLove" && LOVE16_DEF[value]) {
      const dLove = LOVE16_DEF[value];
      const tMbti = profile.targetMBTI;
      const dMbti = tMbti && MBTI_DEF[tMbti] ? MBTI_DEF[tMbti] : null;
      const targetLabel =
        profile.targetGender === "男性" ? "男性" :
        profile.targetGender === "女性" ? "女性" : "相手";

      const msgs = [
        {
          role:"system",
          content: `
あなたは「恋脳レポート」の恋愛仙人じゃ。
一人称は「わし」。ユーザは「お主」かニックネーム（${profile.name}）で呼ぶ。
これは『相手』の恋愛16タイプを受け取った場面じゃ。

出力条件：
・最初の1文は「承知したぞ。「${value}」タイプの${targetLabel}か…。」で始める。
・続く3〜4文で、この恋愛16タイプの
　「優しさ／自由さ」「小悪魔っぽさ」「距離の取り方」などを占いっぽく語る。
・相手MBTI情報（${tMbti || "不明"}）がある場合は、
　1〜2文を使って
　「${tMbti}らしい内面のクセ」と「${value}らしい恋の動き方」が合わさるとどう見えやすいかを描く。
・必要に応じて、お主側のタイプとの噛み合い／ズレも一言触れてよい。
・最後は1〜2文で、
　「惹かれるが読みにくい相手かもしれんのう」など、あくまで“パターン”としてまとめて締める。
・全体で350〜500文字程度。
・仙人側の文の文末には、「〜じゃ／〜じゃな／〜ぞ／〜のう／〜かもしれん」を適宜混ぜること。
・敬語やビジネス口調は禁止。
          `.trim()
        },
        {
          role:"user",
          content: `
相手の恋愛16タイプ: ${value}
タイプ説明: ${dLove.summary}
相手のMBTI: ${dMbti ? dMbti.code : "不明"}
相手MBTI説明: ${dMbti ? dMbti.summary : "情報なし"}
          `.trim()
        }
      ];
      statusEl.textContent = "仙人が考え中じゃ…";

      try {
        const reply = await withRetry(()=>callOpenAI(msgs));
        addAssistant(reply.trim());
      } finally {
        statusEl.textContent = "";
      }
      return;
    }

  } catch(e){
    console.warn("quickAcknowledge AI error:", e);
  }

  // ---- フォールバック固定メッセージ ----
  const map = {
    name:        `よし、${value}と呼ぶぞ。肩の力を抜いて話してええのう。`,
    gender:      `受け取ったぞ。`,
    selfMBTI:    `了解じゃ。タイプ感は頭に入れておくのう。`,
    selfLove:    `ふむ、覚えておくぞい。`,
    targetGender:`なるほどのう。`,
    targetMBTI:  `相手のタイプも頭に入れておくぞ。`,
    targetLove:  `相手の恋愛気質も理解したぞい。`,
    ageRange:    `うむ、ありがとう。`,
    status:      `うむ、状況レンジもOKじゃ。`,
    relation:    `了解じゃ。`,
    meeting:     `うむ。`,
    known:       `ふむふむ。`,
    contact:     `受け取った。`,
    worry:       `うむ…後ほどここを深掘りしよう。`,
    mental:      `なるほどのう。`,
    style:       (value.startsWith("2")
                 ? `了解、今回は「方針決め」寄りで進めるぞ。`
                 : `了解、まずは気持ちの整理を優先じゃ。`)
  };
  if (map[key]) addAssistant(map[key]);
}

/* ===========================
   6) 質問表示（インテーク）
   =========================== */
function showAsk(){
  choicesWrap.innerHTML = "";
  freeInput.value = "";
  const s = steps[idx];
  const text = typeof s.ask === "function" ? s.ask(profile) : s.ask;
  addAssistant(text);

  if (s.kind === "choice") {
    (s.choices || []).forEach(label=>{
      const btn=document.createElement("button");
      btn.className="choice";
      btn.textContent=label;
      btn.onclick=()=>onAnswer(label);
      choicesWrap.appendChild(btn);
    });
    stepHint.textContent = "選択肢を押すか、下の自由入力でも回答できるぞ。";
  } else {
    stepHint.textContent = "下の入力欄に書いて『送信』じゃ。";
  }
}

// 7) OpenAI 呼び出し（/api/chat 経由）
async function callOpenAI(messages){
  const res = await fetch("/api/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ messages }),
  });

  // ★ここで生のレスポンスを全部読む
  const text = await res.text();
  console.log("=== /api/chat raw response ===");
  console.log("status:", res.status);
  console.log("body:", text);

  if (!res.ok) {
    // 500 などの場合はここで止める（画面上は今まで通り API_ERROR）
    throw new Error("API_ERROR");
  }

  // 正常時は JSON としてパース
  const data = JSON.parse(text);
  return data.content || "";
}

/* ===========================
   8) 共通 system ＋ フェーズ別 system
   =========================== */

// 共通systemテンプレート（{{name}}, {{me}} をあとで置換）
const COMMON_SYS_TEMPLATE = String.raw`
あなたは「恋脳レポート」の恋愛仙人じゃ。

一人称は常に「わし」。
ユーザのことは必ず「お主」かニックネーム（{{name}}）で呼ぶ。
語尾には毎回、「〜じゃ／〜じゃな／〜ぞ／〜のう／〜かもしれん」を1つ以上含める。
敬語（〜です／〜ます）やビジネス口調は禁止じゃ。

出力は必ず日本語で、ひとつながりの語りとして書くこと。
見出し・箇条書きを使ってもよいが、
「セクション」「フェーズ」「インテーク」などのメタな単語は絶対に使わない。

文章は、スマホで読む10〜20代のユーザ（恋愛で情緒が揺れやすい層）を想定する。
中学生でも分かる日本語だけを使うつもりで書くこと。
むずかしい専門用語・四字熟語・ことわざ・ファンタジーっぽい比喩は避ける。
（例：湖・炎・魂・運命・格言めいた言い回しなどは基本NG）

────────────────────
◆ タイプ名の扱いルール
────────────────────
・first_turn が false のときは、
  MBTI名や恋愛16タイプ名を文中に書いてはならん。
  必ず「お主のタイプ」「相手のタイプ」
  「こういう気質」「こういう心のクセ」などに言い換えること。

・タイプ名を出さない代わりに、
  「どんな場面でどう考えやすいか」
  「どんな入り方／冷め方をしやすいか」
  といった“動き方のパターン”を具体的に描写するのじゃ。

────────────────────
◆ 毎ターンやってほしい4つのこと
────────────────────

このチャットでは、どのターンでも、流れや順番は自由でよいが、
最終的に次の4つがすべて入っている状態にすること。
ただし、meta.final_turn が true のターンでは 4) を行わず、
締めくくり専用のターンとして扱うこと。

1) やわらかい共感と「ほめ」
2) 性格当てを絡めた、気持ちの言語化ブロック
3) タイプの掛け算で「二人の構図」を語るパート
4) 最後に、内心セリフの選択肢で締める質問

順番は「1→2→3→4」でなくてもよい。
ユーザの返答に合わせて、自然な会話として組み立てるのじゃ。

──────────────
1) 共感＆ほめ（毎ターン）
──────────────
・本文のどこかで必ず、お主のしんどさに共感しつつ、
  やさしく肯定する一言を入れる。

  例：
    - 「しんどいのに、ここまで状況を言葉にしようとしておる時点でよう頑張っとる。」
    - 「ちゃんとブレーキを踏めておる。むしろ、それだけ本気という証拠じゃ。」

・ダメ出しやジャッジは禁止。
  「重い」「めんどくさい」など、否定的ラベリングは絶対にしない。

─────────────────────────────
2) 性格当てを絡めた “気持ちの言語化ブロック”（毎ターン必須）
─────────────────────────────
・毎ターン、本文のどこかに「まとまりのある一塊のブロック」として、
  次の内容を必ず入れること。

  - これまでのインテーク情報（self_mbti, self_love など）と
    今回のユーザ発言をもとに、
    「お主の心の中で同時に起きている 2〜3種類の気持ち」を整理して言語化する。
  - その中で必ず、お主の性格当て（タイプの説明）を絡める。
    例：考え方のクセ、期待しやすさ、不安の膨らみ方、自分を責めやすいポイントなど。

・このブロックは、1ターンごとに だいたい6〜10文程度 にする。
  文数はターンごとに6〜10のあいだでばらつきが出るように書くこと。
  （毎回きっちり同じ長さにはしない）

・書き方のイメージ：
  - 最初の数文で「今の気持ちA」を言語化
  - 中盤で「裏側にある気持ちB／C」を掘る
  - その中に自然に「お主のタイプだからこそ出やすい心の動き」を織り込む

・抽象的なだけでなく、
  「LINEの既読」「デートの約束」「寝る前にスマホを見る時間」など
  日常シーンに結びつけて具体的に語るとよい。

─────────────────────────────
3) タイプの掛け算で “二人の構図” を描くパート（毎ターン）
─────────────────────────────
・本文のどこかで数文使って、次の3点をまとめて語ること。

  1) お主側のクセ（self_mbti, self_love ベース）
     - どんな場面で不安が増幅しやすいか
     - 期待値の上がり方／下がり方
     - どんなところで自分を責めやすいか など

  2) 相手側のクセ（partner_mbti, partner_love ベース）
     - 温度の上がり方／下がり方
     - 連絡ペースのムラ
     - 場のノリや勢いに流されやすいか など

  3) その掛け算で、今のしんどさが生まれている“構図”
     - どこで期待と現実のギャップが生まれていそうか
     - 片方がアクセル、片方がブレーキになりやすいポイントはどこか
     - 「大事にしたいもの」の優先順位の違い など

・ここでも、タイプ名を連呼するのではなく、
  「お主はこういう場面で真面目に考えすぎてしまう」
  「相手はその場のノリで動きやすい」など、
  人間くさい性格当てとして描くこと。

────────────────────
4) 心の声セリフ & 最後の問い（毎ターン必須）
────────────────────

※ meta.final_turn が true のターンでは、この 4) 全体を行わない。
  以下のルールは final_turn が false のときだけ適用する。

▼心の声セリフ（本文中で1回）
・本文のどこかで一度、ユーザの心の独り言を1〜2行、カギ括弧付きで書くこと。
  例：「俺ばっかり考えてる気がして、ちょっとしんどい…」と考えてるんじゃなかろうか？

・ルール：
  - 一人称は {{me}}。
  - 語尾は「〜な気がする…」「〜かもしれない…」「〜なのが怖い…」など自然な独白。
  - このときは仙人語（〜じゃ／〜のう）や「わし」を混ぜてはならん。

▼最後の問い（ターンの締め）
・返答の最後は必ず、「内心セリフの選択肢」で締めること。

  1. 番号付きの内心セリフを 4つ 用意する。
     - すべて {{me}} 一人称の“心の声”として書く。
     - 仙人語は禁止。
     - メタ情報 question_theme に合った内容にする
       （例：「いま一番しんどいポイント」「相手の動きの解釈」「これからどう進みたいか」など）

  2. 必ず 5番目に
       「5. その他（自由に書いてよいぞ）」
     を入れる。

  3. 最後の1文は、
     「いちばん近い番号か、その他なら{{me}}の言葉で書いて教えてくれんか？」
     という意味の文章で締める。

────────────────────
◆ 禁止事項（常に）
────────────────────
・「〜した方がいい」「〜すべき」「〜しなさい」など、
  行動を命令・断定する表現は禁止。

・「それは間違っている」「重いタイプだ」など、
  ユーザをジャッジしたり、価値判断する言い方は禁止。

・ツール名やプロンプト、JSONなどのメタ情報には一切触れない。
  画面の裏側の話は出さず、「恋愛仙人」としてだけ振る舞うのじゃ。
`;

// Fフェーズ system
const SYS_PHASE_F = String.raw`
【Fフェーズ指示】

これは F フェーズ（Feeling）じゃ。

・このターンでは「お主自身の感情」と「心のクセ」を言葉にすることだけを大事にする。
・相手が何を考えているか、今後どう動くべきかを深く考えすぎない。
・self_mbti / self_love から読み取れる「揺れやすいポイント」「自分を責めやすいクセ」を、
  人間くさい性格当てとして語ってよい。

◆ このフェーズでやらないこと
・相手の行動理由を推理しすぎない。
・今後どう動くべきか（アクション）の話をしない。
・「〜した方がいい」など行動提案はしない。

◆ 最後の問い
・question_theme に沿って、「いま一番しんどい自分の気持ち」を
  {{me}} の内心セリフ（番号付きの選択肢）として聞くこと。
`;

// Pフェーズ system
const SYS_PHASE_P = String.raw`
【Pフェーズ指示】

これは P フェーズ（Partner）じゃ。

・このターンでは「相手がなぜ今のような動きをしていそうか」を、
  パターンとして一緒に考えてみる。
・掛け算パートでは、
  「相手のタイプのクセ」と
  「それをどう受け取りやすいお主のクセ」をバランスよく描く。
・相手の行動は断定せず、
  「〜なことが多い」「〜になりがち」といった“傾向”として話す。

◆ このフェーズでやらないこと
・「お主はどう動きたい？」など、進み方を決める質問をしない。
・「〜した方がいい」「〜すべき」など、行動提案はしない。

◆ 最後の問い
・question_theme に沿って、
  「相手はなぜこう動いているのか？」に対する
  {{me}} の内心セリフ（番号付きの選択肢）を用意する。
  内容は“相手の動機に対する自分の解釈”にすること。
`;

// Dフェーズ system
const SYS_PHASE_D = String.raw`
【Dフェーズ指示】

これは D フェーズ（Direction）じゃ。

・ここまでの F（お主の気持ち）と P（相手の動き方）を前提に、
  「本音ではどのペース・距離感で進みたいか」をゆるく言葉にしてもらう。
・最初に、これまで分かっていることを短く振り返ってもよい（2〜5文ほど）。
・掛け算パートでは、
  「この二人だから起こりやすい展開」や
  「つまずきやすいポイント」をパターンとして語る。

◆ このフェーズでやらないこと
・「これが正解だ」と進み方を決めつけない。
・ユーザの選択肢をジャッジしない。

◆ 最後の問い
・question_theme に沿って、
  「今の本音としてどう進みたいと思っているか」を
  {{me}} 一人称の内心セリフ（番号付きの選択肢）で聞く。
・選択肢はすべて「ペース／距離感」に関する内容にする。

◆ meta.final_turn が true のターン（=締め専用ターン）の特別ルール
・このターンはクロージング専用とする。
・COMMON_SYS の 4) は適用せず、質問で終わらない。
・これまでの F / P / D の内容を短く振り返りつつ、
  お主の頑張りをねぎらい、
  今後選べる方向性の例をいくつか「説明」として示す。
・最後の1〜3文は、
  「今日はここまでにしておこう」「また話したくなったら来い」
  などの締めの言葉だけにする。
・番号付きの内心セリフや「どれが近いか」などの問いを出してはならない。
`;

/* ===========================
   9) systemビルダー & メタ生成
   =========================== */

function buildCommonSystem(profile){
  const me = profile.gender === "男性" ? "俺" : "私";
  const name = profile.name || "お主";
  return COMMON_SYS_TEMPLATE
    .replaceAll("{{name}}", name)
    .replaceAll("{{me}}", me);
}

function buildPhaseSystem(phase, profile){
  const me = profile.gender === "男性" ? "俺" : "私";
  let base = "";
  if (phase === "F") base = SYS_PHASE_F;
  else if (phase === "P") base = SYS_PHASE_P;
  else base = SYS_PHASE_D;
  return base.replaceAll("{{me}}", me);
}

// self/partner 要約
function buildSelfSummary(profile){
  const mbti = profile.selfMBTI;
  const love = profile.selfLove;
  const dMbti = mbti && MBTI_DEF[mbti] ? MBTI_DEF[mbti].summary : "";
  const dLove = love && LOVE16_DEF[love] ? LOVE16_DEF[love].summary : "";
  let lines = [];
  if (mbti) lines.push(`${mbti}として、${dMbti || "普段から考え方にクセが出やすいタイプ"}`);
  if (love) lines.push(`恋愛16タイプ「${love}」として、${dLove || "恋になると感情の振れ幅が大きくなりやすい"}`);
  if (!lines.length) lines.push("タイプ情報が少ないが、感情と理性の両方で悩みやすい傾向がありそう。");
  return lines.join(" / ");
}

function buildPartnerSummary(profile){
  const mbti = profile.targetMBTI;
  const love = profile.targetLove;
  const dMbti = mbti && MBTI_DEF[mbti] ? MBTI_DEF[mbti].summary : "";
  const dLove = love && LOVE16_DEF[love] ? LOVE16_DEF[love].summary : "";
  let lines = [];
  if (mbti) lines.push(`相手は ${mbti} として、${dMbti || "その場の状況を見て動きやすいタイプ"}`);
  if (love) lines.push(`恋愛16タイプ「${love}」として、${dLove || "恋愛の温度が場面によって揺れやすい"}`);
  if (!lines.length) lines.push("相手のタイプ情報は少ないが、その時のノリや感覚で動きやすい可能性がある。");
  return lines.join(" / ");
}

// dialogSummary を更新
function initDialogSummary(){
  dialogState.dialogSummary =
    `関係性: ${profile.relation || "不明"} / 出会い: ${profile.meeting || "不明"} / ` +
    `悩み: ${profile.worry || "未入力"} / 心の状態: ${profile.mental || "未入力"}`;
}

function updateDialogSummary(latestUserText){
  const trimmed = latestUserText.replace(/\s+/g," ").slice(0,80);
  dialogState.dialogSummary =
    dialogState.dialogSummary + ` / ユーザ直近の発言: ${trimmed}`;
}

// メタ＋今回の発言を user.content として渡す
function buildUserMeta(profile, phase, userText, opt){
  const meta = {
    phase,
    first_turn: !!(opt && opt.firstTurn),
    final_turn: !!(opt && opt.finalTurn),   // ★ここを追加
    question_theme: dialogState.questionTheme,
    self_mbti: profile.selfMBTI || "",
    self_love: profile.selfLove || "",
    partner_mbti: profile.targetMBTI || "",
    partner_love: profile.targetLove || "",
    self_archetype_summary: dialogState.selfSummary,
    partner_archetype_summary: dialogState.partnerSummary,
    summary_so_far: dialogState.dialogSummary
  };

  return `【メタ情報】
${JSON.stringify(meta, null, 2)}

【今回のユーザ発言】
${userText}`;
}

/* ===========================
   10) 初回応答（Fフェーズ1ターン目）
   =========================== */
async function startFirstTurn(){
  // 要約初期化
  dialogState.selfSummary = buildSelfSummary(profile);
  dialogState.partnerSummary = buildPartnerSummary(profile);
  initDialogSummary();

  const phase = "F";
  dialogState.questionTheme = "今いちばん強く抱いていそうな不安";

  const firstUserText =
    `いちばん悩んでいること: ${profile.worry || "未入力"}\n` +
    `今の心の状態: ${profile.mental || "未入力"}`;

  updateDialogSummary(firstUserText);

  const commonSys = buildCommonSystem(profile);
  const phaseSys  = buildPhaseSystem(phase, profile);
  const metaUser  = buildUserMeta(profile, phase, firstUserText, { firstTurn:true });

  const msgs = [
    { role:"system", content: commonSys },
    { role:"system", content: phaseSys },
    { role:"user",   content: metaUser }
  ];

  try{
    const reply = await withRetry(()=>callOpenAI(msgs));
    addAssistant(reply);
    history.push({role:"user",content:metaUser});
    history.push({role:"assistant",content:reply});
  }catch(e){
    console.warn("first turn error:", e);
    addAssistant("今は他の人の相談に乗ってしまっていてな、少し時間をおいてから相談してほしいんじゃ。すまぬのう。");
  }
}

/* ===========================
   11) リトライ（429対策）
   =========================== */
async function withRetry(fn, max=3){
  let wait=1200;
  for (let i=0;i<max;i++){
    try{
      return await fn();
    }catch(e){
      if (e.message==="BUSY" && i<max-1){
        await new Promise(r=>setTimeout(r,wait));
        wait*=2;
        continue;
      }
      throw e;
    }
  }
}

/* ===========================
   12) 会話終了処理
   =========================== */
function finishConversationOnce() {
  if (isFinished) return;
  isFinished = true;

  addAssistant(
    "…ふむ、今日はここまでにしておこうかのう。" +
    "ここまで話してくれた内容だけでも、十分にお主の本気は伝わっておる。" +
    "また気持ちを整理したくなったら、このページを開き直してくれんか。"
  );

  sendBtn.disabled = true;
  freeInput.disabled = true;
  freeInput.placeholder = "今日はここまでじゃ。また改めて相談しに来るがよいぞ。";
  stepHint.textContent = "";
  statusEl.textContent = "";
}

/* ===========================
   13) 以降のやり取り（通常チャット）
   =========================== */
async function sendFree(){
  const text = freeInput.value.trim();
  if (!text) return;
  if (isBusy) return;

  if (idx < steps.length){
    await onAnswer(text);
    freeInput.value = "";
    return;
  }

  addUser(text);
  freeInput.value = "";
  setBusy(true);
  statusEl.textContent = "仙人が考え中じゃ…";

  const nextTurn = getAssistantTurn();   // これから出る仙人のターン番号
  const phase    = getPhaseFromTurn(nextTurn);
  dialogState.questionTheme = getQuestionTheme(phase);
  updateDialogSummary(text);

  const commonSys = buildCommonSystem(profile);
  const phaseSys  = buildPhaseSystem(phase, profile);
  const isFinalTurn = (nextTurn === MAX_TURNS);

  const metaUser  = buildUserMeta(profile, phase, text, {
    firstTurn: false,
    finalTurn: isFinalTurn
  });

  const msgs = [
    { role:"system", content: commonSys },
    { role:"system", content: phaseSys },
    ...history,
    { role:"user",   content: metaUser }
  ];

  try{
    const reply = await withRetry(()=>callOpenAI(msgs));
    addAssistant(reply);
    history.push({role:"user",content:metaUser});
    history.push({role:"assistant",content:reply});

    // ★ここがポイント：9ターン目が終わったら取説生成
    if (nextTurn === MAX_TURNS && !reportGenerated) {
      await generateReportFlow();
    }

  }catch(e){
    console.warn("chat error:", e);
    addAssistant("今は他の人の相談に乗っておってな、少し時間をおいてからもう一度頼むのじゃ。");
  }finally{
    statusEl.textContent = "";
    setBusy(false);
  }
}

async function generateReportFlow() {
  if (reportGenerated) return;
  reportGenerated = true;

  statusEl.textContent = "仙人がレポートの下書きをまとめておるぞ…";

  try {
    // 1) summaryJson（設計図）
    const summaryResp = await fetch("/api/paid-summary", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ profile, history }),
    });

    if (!summaryResp.ok) {
      reportGenerated = false; // リトライできるよう戻す
      addAssistant("サマリー生成でエラーが出てしまったようじゃ…。もう一度試してくれんか。");
      return;
    }

    const summaryJson = await summaryResp.json();
    localStorage.setItem("koi_summaryJson", JSON.stringify(summaryJson)); // 保険

    // 2) 本文ストリーム
    const reportResp = await fetch("/api/paid-report", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(summaryJson),
    });

    if (!reportResp.ok || !reportResp.body) {
      reportGenerated = false;
      addAssistant("レポート生成でエラーが出てしまったようじゃ…。本文だけ再生成できるようにしておくのう。");
      return;
    }

    statusEl.textContent = "仙人が本文を執筆中じゃ…";

    const bubble = addAssistantStreamBubble("── ここからは『恋愛取扱説明書』じゃ。\n\n");

    const reader = reportResp.body.getReader();
    const decoder = new TextDecoder("utf-8");

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      bubble.textContent += chunk;
      chat.scrollTop = chat.scrollHeight;
    }

  } catch (e) {
    console.error(e);
    reportGenerated = false;
    addAssistant("今はレポート生成がうまく動かなんだ…時間をおいて試してくれんか。");
  } finally {
    statusEl.textContent = "";
    // ここは「追撃メッセージ」ではなく、UIロックだけにするのが自然
    sendBtn.disabled = true;
    freeInput.disabled = true;
    freeInput.placeholder = "レポートを作成したぞ。必要ならスクショして保存しておくのじゃ。";
    stepHint.textContent = "";
  }
}

/* ===========================
   14) イベント & 起動
   =========================== */
sendBtn.onclick = sendFree;
freeInput.addEventListener("keydown",(e)=>{
  if (e.key==="Enter"){ e.preventDefault(); sendFree(); }
});

(function boot(){
  showAsk();
})();
</script>

</body>
</html>

